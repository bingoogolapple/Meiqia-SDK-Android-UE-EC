<resources>
    <string name="app_name">美洽x电商</string>
    <string name="toast_exit_tip">再按一次返回键退出美洽x电商</string>
    <string name="loading_data">数据加载中...</string>
    <string name="loading_data_failure">数据加载失败</string>

    <string name="content_one">
        软件开发的不朽经典\n
        生动阐述重构原理和具体做法\n
        普通程序员进阶到编程高手必须修炼的秘笈\n
        重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。
        本书凝聚了软件开发社区专家多年摸索而获得的宝贵经验，拥有不因时光流逝而磨灭的价值。今天，无论是重构本身，业界对重构的理解，还是开发工具对重构的支持力度，都与本书最初出版时不可同日而语，但书中所蕴涵的意味和精华，依然值得反复咀嚼，而且往往能够常读常新。
    </string>

    <string name="content_two">
        本书清晰揭示了重构的过程，解释了重构的原理和最佳实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。书中给出了70 多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。本书提出的重构准则将帮助你一次一小步地修改你的代码，从而减少了开发过程中的风险。
    </string>

    <string name="content_three">
        Martin Fowler，世界软件开发大师，在面向对象分析设计、UML、模式、XP和重构等领域都有卓越贡献，现为著名软件开发咨询公司ThoughtWorks的首席科学家。他的多部著作《分析模式》、《UML精粹》和《企业应用架构模式》等都已经成为脍炙人口的经典。\n
        译者介绍\n
        熊节，ThoughtWorks中国公司的高级咨询师、架构师和项目经理，在大型企业应用及互联网应用的架构和管理方面拥有丰富经验。作为敏捷方法学顾问和重构专家，他拥有在各种技术平台、编程语言、软件形态的项目中实施重构的丰富经验，并曾主持极具挑战性的超大规模电信软件系列重构工作。
    </string>

    <string name="content_four">
        第1章 重构，第一个案例 1\n
        1.1 起点 1\n
        1.2 重构的第一步 7\n
        1.3 分解并重组statement() 8\n
        1.4 运用多态取代与价格相关的条件逻辑 34\n
        1.5 结语 52\n
        第2章 重构原则 53\n
        2.1 何谓重构 53\n
        2.2 为何重构 55\n
        2.3 何时重构 57\n
        2.4 怎么对经理说 60\n
        2.5 重构的难题 62\n
        2.6 重构与设计 66\n
        2.7 重构与性能 69\n
        2.8 重构起源何处 71\n
        第3章 代码的坏味道 75\n
        3.1 Duplicated Code（重复代码） 76\n
        3.2 Long Method（过长函数） 76\n
        3.3 Large Class（过大的类） 78\n
        3.4 Long Parameter List（过长参数列） 78\n
        3.5 Divergent Change（发散式变化） 79\n
        3.6 Shotgun Surgery（霰弹式修改） 80\n
        3.7 Feature Envy（依恋情结） 80\n
        3.8 Data Clumps（数据泥团） 81\n
        3.9 Primitive Obsession（基本类型偏执） 81\n
        3.10 Switch Statements（switch惊悚现身） 82\n
        3.11 Parallel InheritanceHierarchies（平行继承体系） 83\n
        3.12 Lazy Class（冗赘类） 83\n
        3.13 Speculative Generality（夸夸其谈未来性） 83\n
        3.14 Temporary Field（令人迷惑的暂时字段） 84\n
        3.15 Message Chains（过度耦合的消息链） 84\n
        3.16 Middle Man（中间人） 85\n
        3.17 Inappropriate Intimacy（狎昵关系） 85\n
        3.18 Alternative Classes with Different Interfaces（异曲同工的类） 85\n
        3.19 Incomplete Library Class（不完美的库类） 86\n
        3.20 Data Class（纯稚的数据类） 86\n
        3.21 Refused Bequest（被拒绝的遗赠） 87\n
        3.22 Comments（过多的注释） 87\n
        第4章 构筑测试体系 89\n
        4.1 自测试代码的价值 89\n
        4.2 JUnit测试框架 91\n
        4.3 添加更多测试 97\n
        第5章 重构列表 103\n
        5.1 重构的记录格式 103\n
        5.2 寻找引用点 105\n
        5.3 这些重构手法有多成熟 106\n
        第6章 重新组织函数 109\n
        6.1 Extract Method（提炼函数） 110\n
        6.2 Inline Method（内联函数） 117\n
        6.3 Inline Temp（内联临时变量） 119\n
        6.4 Replace Temp with Query（以查询取代临时变量） 120\n
        6.5 Introduce Explaining Variable（引入解释性变量） 124\n
        6.6 Split Temporary Variable（分解临时变量） 128\n
        6.7 Remove Assignments to Parameters（移除对参数的赋值） 131\n
        6.8 Replace Method with Method Object（以函数对象取代函数） 135\n
        6.9 Substitute Algorithm（替换算法） 139\n
        第7章 在对象之间搬移特性 141\n
        7.1 Move Method（搬移函数） 142\n
        7.2 Move Field（搬移字段） 146\n
        7.3 Extract Class（提炼类） 149\n
        7.4 Inline Class（将类内联化） 154\n
        7.5 Hide Delegate（隐藏“委托关系”） 157\n
        7.6 Remove Middle Man（移除中间人） 160\n
        7.7 Introduce Foreign Method（引入外加函数） 162\n
        7.8 Introduce Local Extension（引入本地扩展） 164\n
        第8章 重新组织数据 169\n
        8.1 Self Encapsulate Field（自封装字段） 171\n
        8.2 Replace Data Value with Object（以对象取代数据值） 175\n
        8.3 Change Value to Reference（将值对象改为引用对象） 179\n
        8.4 Change Reference to Value（将引用对象改为值对象） 183\n
        8.5 Replace Array with Object（以对象取代数组） 186\n
        8.6 Duplicate Observed Data（复制“被监视数据”） 189\n
        8.7 Change Unidirectional Association to Bidirectional（将单向关联改为双向关联） 197\n
        8.8 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联） 200\n
        8.9 Replace Magic Number with Symbolic Constant（以字面常量取代魔法数） 204\n
        8.10 Encapsulate Field（封装字段） 206\n
        8.11 Encapsulate Collection（封装集合） 208\n
        8.12 Replace Record with Data Class（以数据类取代记录） 217\n
        8.13 Replace Type Code with Class（以类取代类型码） 218\n
        8.14 Replace Type Code with Subclasses（以子类取代类型码） 223\n
        8.15 Replace Type Code with State/Strategy（以State/Strategy取代类型码） 227\n
        8.16 Replace Subclass with Fields（以字段取代子类） 232\n
        第9章 简化条件表达式 237\n
        9.1 Decompose Conditional（分解条件表达式） 238\n
        9.2 Consolidate Conditional Expression（合并条件表达式） 240\n
        9.3 Consolidate Duplicate Conditional Fragments（合并重复的条件片段） 243\n
        9.4 Remove Control Flag（移除控制标记） 245\n
        9.5 Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式） 250\n
        9.6 Replace Conditional with Polymorphism（以多态取代条件表达式） 255\n
        9.7 Introduce Null Object（引入Null对象） 260\n
        9.8 Introduce Assertion（引入断言） 267\n
        第10章 简化函数调用 271\n
        10.1 Rename Method（函数改名） 273\n
        10.2 Add Parameter（添加参数） 275\n
        10.3 Remove Parameter（移除参数） 277\n
        10.4 Separate Query from Modifier（将查询函数和修改函数分离） 279\n
        10.5 Parameterize Method（令函数携带参数） 283\n
        10.6 Replace Parameter with Explicit Methods（以明确函数取代参数） 285\n
        10.7 Preserve Whole Object（保持对象完整） 288\n
        10.8 Replace Parameter with Methods（以函数取代参数） 292\n
        10.9 Introduce Parameter Object（引入参数对象） 295\n
        10.10 Remove Setting Method（移除设值函数） 300\n
        10.11 Hide Method（隐藏函数） 303\n
        10.12 Replace Constructor with Factory Method（以工厂函数取代构造函数） 304\n
        10.13 Encapsulate Downcast（封装向下转型） 308\n
        10.14 Replace Error Code with Exception（以异常取代错误码） 310\n
        10.15 Replace Exception with Test（以测试取代异常） 315\n
        第11章 处理概括关系 319\n
        11.1 Pull Up Field（字段上移） 320\n
        11.2 Pull Up Method（函数上移） 322\n
        11.3 Pull Up Constructor Body（构造函数本体上移） 325\n
        11.4 Push Down Method（函数下移） 328\n
        11.5 Push Down Field（字段下移） 329\n
        11.6 Extract Subclass（提炼子类） 330\n
        11.7 Extract Superclass（提炼超类） 336\n
        11.8 Extract Interface（提炼接口） 341\n
        11.9 Collapse Hierarchy（折叠继承体系） 344\n
        11.10 Form Tem Plate Method（塑造模板函数） 345\n
        11.11 Replace Inheritance with Delegation（以委托取代继承） 352\n
        11.12 Replace Delegation with Inheritance（以继承取代委托） 355\n
        第12章 大型重构 359\n
        12.1 Tease Apart Inheritance（梳理并分解继承体系） 362\n
        12.2 Convert Procedural Design to Objects（将过程化设计转化为对象设计） 368\n
        12.3 Separate Domain from Presentation（将领域和表述/显示分离） 370\n
        12.4 Extract Hierarchy（提炼继承体系） 375\n
        第13章 重构，复用与现实 379\n
        13.1 现实的检验 380\n
        13.2 为什么开发者不愿意重构他们的程序 381\n
        13.3 再论现实的检验 394\n
        13.4 重构的资源和参考资料 394\n
        13.5 从重构联想到软件复用和技术传播 395\n
        13.6 小结 397\n
        13.7 参考文献 397\n
        第14章 重构工具 401\n
        14.1 使用工具进行重构 401\n
        14.2 重构工具的技术标准 403\n
        14.3 重构工具的实用标准 405\n
        14.4 小结 407\n
        第15章 总结 409\n
        参考书目 413\n
        要点列表 417\n
        索引 419\n
    </string>
</resources>
